Creating the new Frame - Module Frame_Creator {#doc_frame_creator}
==============================

[TOC]


# Introduction {#fc-intro}

A new frame will be created with the module Frame_Creator. It consists of multiple small submodules controlled by the FSM Frame_Create_FSM.

The FSM includes two counter. A counter to switch the state after a predefined amount of clock cycles and one for the current position within the outgoing frame.




![](Frame_Create_FSM.png "Diagram of the FSM Frame_Create_FSM")



## sIdle {#fc-idle}

The Frame_Creator is ready for a new frame. Both counter are disabled with a synchronous reset. The FSM informs the module Process_Unit by setting the output Frame_Creator.oNextFrame.

The input Frame_Creator.iFrameStart is set by the Process_Unit, when the next frame is ready. The start- and end-address of the memory is sent via Frame_Creator.iDataStartAddr and Frame_Creator.iDataEndAddr. The FSM enters the state [sPreamble](#fc-preamble) and starts to generate the preamble.




## sPreamble and sPre_read {#fc-preamble}

The module Preamble_Generator is activated by the Frame_Create_FSM.oPreambleActive and starts to generate its pattern. A multiplexer is set to the stream of the Preamble_Generator by Frame_Create_FSM.oSelectTX and the RMII data valid signal Frame_Creator.oTXDV is activated.

The cycle counter is activated to send the preamble for its predefined number of cycles of the constant framemanipulatorPkg.cCreateTime. The state will already be switched _preReadTime_ cycles earlier to __sPre_read__. This state also activates the output of the preamble, but starts with reading the memory Data_Buffer, too. This state is needed to give the DPRAM and the converter of the word size Byte_to_TXData enough time to put out the correct data stream without any delay.


Once the cycle counter reached the end of the preamble, the FSM enters the state [sRead](#fc-read) to put out the frame data. Frames without any data (e.g. truncated frames of the Cut manipulation with a size of zero Bytes) receive their CRC immediately via state [sCrc](#fc-crc). The end of the frame stream is detected with Frame_Create_FSM.iReadBuffDone.


## sRead  and sSafetyRead {#fc-read}

The position counter pCnt is activated, while the cycle counter is inactive again. The frame data are sent from the Data_Buffer, converted by Byte_to_TXData and pass the multiplexer (data stream is selected via Frame_Create_FSM.oSelectTX='11').

Safety frames which should be manipulated are selected by the Packet_Buffer via Frame_Create_FSM.iPacketExchangeEn. Once the frame position reached the offset of the packet Frame_Create_FSM.iPacketStart, the state __sSafetyRead__ will be entered and the output Frame_Create_FSM.oExchangeData activated. _oExchangeData_ activates the Packet_Buffer module with the new packet data which will be used instead of the original data of the Data_Buffer. Once the packet has ended, the FSM returns to the state __sRead__.

Is the end of the frame detected via Frame_Create_FSM.iReadBuffDone, the generated CRC will be put out in state [sCrc](#fc-crc).

## sCrc and sWait_IPG{#fc-crc}

The CRC output is enabled via Frame_Create_FSM.oCrcActive and passes the multiplexer. The CRC is generated by module CRC_calculator during the sates __sRead__ and __sSafetyRead__. At manipulation CRC-Distortion, the CRC will be manipulated by receiving the signal Frame_Creator.iDistCrcEn from Process_Unit.


![](taskCrc.png "Setting of a CRC manipulation")



The state ends after _crcTime_ cycles and enters __sWait_IPG__. The data-valid signal will be set to zero again. After waiting another _ipgTime_ cycles to keep the IPG (the time between two outgoing frames) of 960 ns, before returning to state [sIdle](#fc-idle) and starting with the next frame.




